layout: requirejs
title: RequireJS API
---

<div id="content">
    <div id="directory" class="section">
        <h1>RequireJS API</h1>

        <span class="note">这里是 <a href="https://github.com/jrburke/requirejs/wiki/Upgrading-to-RequireJS-2.0">RequireJS 2.0 API</a>。如果你需要 1.0版本：<a href="http://requirejs.org/docs/1.0/">链接至 1.0</a>。</span>

        <ul class="index mono">
            <li class="hbox"><a href="#usage">使用</a><span class="spacer boxFlex"></span><span class="sect">§§ 1-1.3</span>
            </li>
            <ul>
                <li class="hbox"><a href="#jsfiles">加载 JavaScript 文件</a><span class="spacer boxFlex"></span><span class="sect">§ 1.1</span>
                </li>
                <li class="hbox"><a href="#data-main">data-main 入口</a><span class="spacer boxFlex"></span><span class="sect">§ 1.2</span>
                </li>
                <li class="hbox"><a href="#define">定义模块</a><span class="spacer boxFlex"></span><span class="sect">§ 1.3</span>
                </li>
                <ul>
                    <li class="hbox"><a href="#defsimple">简单的 键/值 对</a><span class="spacer boxFlex"></span><span class="sect">§ 1.3.1</span>
                    </li>
                    <li class="hbox"><a href="#deffunc">定义函数</a><span class="spacer boxFlex"></span><span class="sect">§ 1.3.2</span>
                    </li>
                    <li class="hbox"><a href="#defdep">存在依赖的定义函数</a><span class="spacer boxFlex"></span><span class="sect">§ 1.3.3</span>
                    </li>
                    <li class="hbox"><a href="#funcmodule">定义模块为函数</a><span class="spacer boxFlex"></span><span class="sect">§ 1.3.4</span>
                    </li>
                    <li class="hbox"><a href="#cjsmodule">使用简化的 CommonJS 包装器定义模块</a><span class="spacer boxFlex"></span><span class="sect">§ 1.3.5</span>
                    </li>
                    <li class="hbox"><a href="#modulename">定义命名模块</a><span class="spacer boxFlex"></span><span class="sect">§ 1.3.6</span>
                    </li>
                    <li class="hbox"><a href="#modulenotes">其他注意事项</a><span class="spacer boxFlex"></span><span class="sect">§ 1.3.7</span>
                    </li>
                    <li class="hbox"><a href="#circular">循环依赖</a><span class="spacer boxFlex"></span><span class="sect">§ 1.3.8</span>
                    </li>
                    <li class="hbox"><a href="#jsonp">Specify a JSONP Service Dependency</a><span class="spacer boxFlex"></span><span class="sect">§ 1.3.9</span>
                    </li>
                    <li class="hbox"><a href="#undef">Undefining a Module</a><span class="spacer boxFlex"></span><span class="sect">§ 1.3.10</span>
                    </li>

                </ul>
            </ul>
            <li class="hbox"><a href="#mechanics">机制</a><span class="spacer boxFlex"></span><span class="sect">§§ 2</span>
            </li>
            <li class="hbox"><a href="#config">配置选项</a><span class="spacer boxFlex"></span><span class="sect">§§ 3</span>
            </li>
            <li class="hbox"><a href="#advanced">高阶使用</a><span class="spacer boxFlex"></span><span class="sect">§§ 4-4.6</span>
            </li>
            <ul>
                <li class="hbox"><a href="#packages">Loading Modules from Packages</a><span class="spacer boxFlex"></span><span class="sect">§ 4.1</span>
                </li>
                <li class="hbox"><a href="#multiversion">Multiversion Support</a><span class="spacer boxFlex"></span><span class="sect">§ 4.2</span>
                </li>
                <li class="hbox"><a href="#afterload">Loading Code After Page Load</a><span class="spacer boxFlex"></span><span class="sect">§ 4.3</span>
                </li>
                <li class="hbox"><a href="#webworker">Web Worker Support</a><span class="spacer boxFlex"></span><span class="sect">§ 4.4</span>
                </li>
                <li class="hbox"><a href="#rhino">Rhino Support</a><span class="spacer boxFlex"></span><span class="sect">§ 4.5</span>
                </li>
                <li class="hbox"><a href="#errors">Handling Errors</a><span class="spacer boxFlex"></span><span class="sect">§ 4.6</span>
                </li>
            </ul>
            <li class="hbox"><a href="#plugins">Loader Plugins</a><span class="spacer boxFlex"></span><span class="sect">§§ 5-5.4</span>
            </li>
            <ul>
                <li class="hbox"><a href="#text">Specify a Text File Dependency</a><span class="spacer boxFlex"></span><span class="sect">§ 5.1</span>
                </li>
                <li class="hbox"><a href="#pageload">Page Load Event Support/DOM Ready</a><span class="spacer boxFlex"></span><span class="sect">§ 5.2</span>
                </li>
                <li class="hbox"><a href="#i18n">Define an I18N Bundle</a><span class="spacer boxFlex"></span><span class="sect">§ 5.3</span>
                </li>
            </ul>
        </ul>
    </div>

    <div class="section">
        <h2>
<a href="#usage" name="usage">使用</a>
<span class="sectionMark">§ 1</span>
</h2>

        <h3>
<a href="#jsfiles" name="jsfiles">加载 JavaScript 文件</a>
<span class="sectionMark">§ 1.1</span>
</h3>

        <p>RequireJS 使用了不同于传统 &lt;script&gt; 标签的方法来加载脚本。它可以运行得很快，而且优化得很好，但其主要目标还是鼓励模块化地编码。作为其中的一部分，它鼓励使用<strong>模块 ID</strong>来替代 script 标签中的 URL 。</p>

        <p>RequireJS 加载所有与 <a href="#config-baseUrl">baseUrl</a> 相关的代码。data-main 属性指定的脚本，是加载一个页面最高层级的脚本，而 baseUrl 通常设置为与其相同的目录。<a href="#data-main">data-main 属性</a> 是一个特殊的属性， require.js 在开始加载脚本时会检查该属性。下面是一个<strong>脚本</strong> baseUrl 的例子：</p>

        <pre><code class="html"><span class="comment">&lt;!--这里将 baseUrl 设置为 “scripts” 目录, 并且
    加载一个脚本， 它将具有一个模块 ID 'main'--&gt;</span>
<span class="tag">&lt;<span class="keyword">script</span><span class="attribute"> data-main=<span class="value">"scripts/main.js"</span></span><span class="attribute"> src=<span class="value">"scripts/require.js"</span></span>&gt;</span><span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
</code></pre>

        <p>baseUrl 也可以通过 <a href="#config">RequireJS config</a> 来手动配置。如果没有明确的配置，并且未使用 data-main 属性，baseUrl 将默认设置为运行 RequireJS 的 HTML 页面所在的目录。</p>

        <p>RequireJS 默认假设所有的依赖项都是脚本，因此它不期望在模块 ID 中看到 “.js” 的后缀。RequireJS 会在将模块 ID 转换为路径时，自动补全 “.js” 后缀。通过 <a href="#config-paths">paths 配置</a>，还可以为一组脚本设置路径。相对于传统的 &lt;script&gt; 标签，这些能力可以让你使用更少的字符来加载脚本。</p>

        <p>如果你想直接引用一个脚本，不使用 “baseUrl + paths” 的规则来加载它。如果一个模块 ID 包含下面的字符，ID 将不会使用 “baseUrl + paths” 的配置，而将它当作一个以文档为相对路径的普通 URL：</p>

        <ul>
            <li>以 “.js” 结尾；</li>
            <li>以 “/” 开头；</li>
            <li>包含 URL 协议，如 “http:” 或 “https:”。</li>
        </ul>

        <p>但总的来说，使用 baseUrl 和 “paths” 配置来为模块 ID 设置路径是最好的方式。因为这样可以更灵活地重命名模块，以及为优化构建配置不同的路径。</p>

        <p>类似地，为了避免繁冗的配置，最好避免深度的脚本目录结构，而将所有脚本保持在 baseUrl 下。如果想把第三方的代码分离出你的脚本，可以使用下面这样的目录结构：</p>

        <ul>
            <li>www/
                <ul>
                    <li>index.html</li>
                    <li>js/
                        <ul>
                            <li>app/
                                <ul>
                                    <li>sub.js</li>
                                </ul>
                            </li>
                            <li>lib/
                                <ul>
                                    <li>jquery.js</li>
                                    <li>canvas.js</li>
                                </ul>
                            </li>
                            <li>app.js</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <p>在 index.html 中：</p>

        <pre><code class="html"><span class="tag">&lt;<span class="keyword">script</span><span class="attribute"> data-main=<span class="value">"js/app.js"</span></span><span class="attribute"> src=<span class="value">"js/require.js"</span></span>&gt;</span><span class="tag">&lt;/<span class="keyword">script</span>&gt;</span></code></pre>

        <p>在 app.js 中：</p>

        <pre><code class="javascript">requirejs.config({
    <span class="comment">// 默认从 js/lib 加载所有模块 ID</span>
    baseUrl: <span class="string">'js/lib'</span>,
    <span class="comment">// 除非，模块 ID 以 “app” 开头，</span>
    <span class="comment">// 从 js/app 目录加载它。</span>
    <span class="comment">// path 配置是相对于 baseUrl的，</span>
    <span class="comment">// 并且不包含 “.js” 扩展名，</span>
    <span class="comment">// 因为 path 配置可能是一个目录。</span>
    paths: {
        app: <span class="string">'../app'</span>
    }
});

<span class="comment">// 开始应用主逻辑。</span>
requirejs([<span class="string">'jquery'</span>, <span class="string">'canvas'</span>, <span class="string">'app/sub'</span>],
<span class="function"><span class="keyword">function</span> <span class="params">($, canvas, sub)</span> {</span>
    <span class="comment">// jQuery，canvas 以及 app/sub 模块都已加载，并可以在这使用了。</span>
});
</code></pre>

        <p>注意上面的例子，jQuery 这样的第三方库文件中没有出现版本号。如果需要记录，建议将版本号存储到独立的文本文件中，或者使用 <a href="https://github.com/volojs/volo">volo</a> 这样的工具，它会在 package.json 中打上版本号，但在硬盘上保存文件为 “jquery.js”。这允许你使用最少的配置，而不用为每个第三方库进行 “paths” 配置。例如，配置 “jquery” 为 “jquery-1.7.2”。</p>

        <p>理想情况下，你加载的脚本都是通过 <a href="#define">define()</a> 定义的模块。但你也许需要一些传统/遗留的那些，未通过 define() 来定义依赖项的“浏览器全局变量”脚本。这种情况，可以使用 <a href="#config-shim">shim config</a> 来正确地定义依赖。</p>

        <p>如果你没有定义依赖，可能会出现加载错误，因为 RequireJS 会为了速度而异步无序加载。</p>

        <h3>
<a href="#data-main" name="data-main">data-main 入口</a>
<span class="sectionMark">§ 1.2</span>
</h3>

        <p>data-main 属性是一个特殊的属性，require.js 会检测它来开始加载脚本：</p>

        <pre><code class="html"><span class="comment">&lt;!-- 当 require.js 加载后，会为 scripts/main.js
         注入一个 script 标签(带有 async 属性) --&gt;</span>
<span class="tag">&lt;<span class="keyword">script</span><span class="attribute"> data-main=<span class="value">"scripts/main"</span></span><span class="attribute"> src=<span class="value">"scripts/require.js"</span></span>&gt;</span><span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
</code></pre>

        <p>你会通常使用 data-main 脚本来<a href="#config">设置配置项</a>，然后加载应用的第一个模块。注意：require.js 为 data-main 模块生成的 script 标签包含 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async">async 属性</a>。这意味着<strong>你不能假设 data-main 脚本的加载与执行，会在同页面后面引用的脚本前结束。</strong>
        </p>

        <p>例如，当 require.config 的 'foo' 模块路径没有在它被 require() 前设置，这样的写法会概率性地失败：</p>

        <pre><code class="html"><span class="tag">&lt;<span class="keyword">script</span><span class="attribute"> data-main=<span class="value">"scripts/main"</span></span><span class="attribute"> src=<span class="value">"scripts/require.js"</span></span>&gt;</span><span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
<span class="tag">&lt;<span class="keyword">script</span><span class="attribute"> src=<span class="value">"scripts/other.js"</span></span>&gt;</span><span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
</code></pre>

        <pre><code class="javascript"><span class="comment">// main.js的内容：</span>
require.config({
    paths: {
        foo: <span class="string">'libs/foo-1.1.3'</span>
    }
});
</code></pre>
        <pre><code class="javascript"><span class="comment">// other.js的内容：</span>

<span class="comment">// 这段代码可能会在 main.js 中的 require.config() 执行前被调用。</span>
<span class="comment">// 这种情况下，require.js 会尝试加载 'scripts/foo.js'</span>
<span class="comment">// 而不是 'scripts/libs/foo-1.1.3.js'</span>
require( [<span class="string">'foo'</span>], <span class="function"><span class="keyword">function</span><span class="params">( foo )</span> {</span>

});
</code></pre>

        <h3>
<a href="#define" name="define">定义模块</a>
<span class="sectionMark">§ 1.3</span>
</h3>  

        <p>模块不同于传统的脚本文件，它定义了一个作用域良好定义的对象，来防止对全局命名空间的污染。它可以清楚地列出它的依赖，并且不用引用全局对象，就能在定义该模块的函数中，以参数的形式获得这些依赖的引用。RequireJS中的模块，是<a href="http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth">Module Pattern（模块模式）</a>的扩展，具有不需要全局变量就能引用其他模块的好处。</p>

        <p>RequireJS的语法，可以让模块更快地加载，甚至是无序地加载，但以正确的依赖顺序执行。因为没有创建全局变量，使得<a href="#multiversion">在页面中加载一个模块的多个版本</a>成为了可能。</p>

        <p>（如果你熟悉或正在使用 CommonJS 模块，请参见 <a href="commonjs.html">CommonJS Notes</a> 来了解 RequireJS的模块格式是如何映射到CommonJS模块的）。</p>

        <p>每个文件应该只定义<strong>一个</strong>模块，多个模块可以通过<a href="optimization.html">优化工具</a>打包成一个文件。</p>

        <div class="subSection">
            <h4>
<a href="#defsimple" name="defsimple">简单的 键/值 对</a>
<span class="sectionMark">§ 1.3.1</span>
</h4>

            <p>如果模块没有任何依赖，而且它只是键/值对的集合，那么直接将对象字面量传给define()：</p>

            <pre><code class="javascript"><span class="comment">// my/shirt.js中：</span>
define({
    color: <span class="string">"black"</span>,
    size: <span class="string">"unisize"</span>
});
</code></pre>
        </div>

        <div class="subSection">
            <h4>
<a href="#deffunc" name="deffunc">定义函数</a>
<span class="sectionMark">§ 1.3.2</span>
</h4>

            <p>如果模块没有依赖，但是需要一个函数来做一些初始化工作，那么传递这个函数给define()来定义它自己：</p>

            <pre><code class="javascript"><span class="comment">// my/shirt.js 现在做一些初始工作</span>
<span class="comment">// 在返回该模块的定义之前。</span>
define(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">// 这里做一些初始工作</span>

    <span class="keyword">return</span> {
        color: <span class="string">"black"</span>,
        size: <span class="string">"unisize"</span>
    }
});
</code></pre>
        </div>

        <div href="#subSection" class="subSection">
            <h4><a href="#defdep" name="defdep">存在依赖的定义函数</a><span class="sectionMark">§ 1.3.3</span></h4>

            <p>如果模块存在依赖，第一个参数应该是依赖名称的数组，第二个参数是定义函数。一旦所有的依赖完成了加载，会马上调用定义函数。定义函数应该返回定义模块的对象。加载后的依赖项将以参数的形式传递给定义函数，它们的顺序和依赖名称的数组保持一致：</p>

            <pre><code class="javascript"><span class="comment">// my/shirt.js 现在有了依赖，cart 和 inventory</span>
<span class="comment">// 与 shirt.js 在同一个目录</span>
define([<span class="string">"./cart"</span>, <span class="string">"./inventory"</span>], <span class="function"><span class="keyword">function</span><span class="params">(cart, inventory)</span> {</span>
        <span class="comment">// 返回定义 “my/shirt” 模块的对象。</span>
        <span class="keyword">return</span> {
            color: <span class="string">"blue"</span>,
            size: <span class="string">"large"</span>,
            addToCart: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                inventory.decrement(<span class="keyword">this</span>);
                cart.add(<span class="keyword">this</span>);
            }
        }
    }
);
</code></pre>

            <p>在这个例子中，创建了 my/shirt 模块。它依赖 my/cart 和 my/inventory。在磁盘上，文件是这样组织的：</p>

            <ul>
                <li>my/cart.js</li>
                <li>my/inventory.js</li>
                <li>my/shirt.js</li>
            </ul>

            <p>定义函数调用上述的两个参数，“cart” 和 “inventory”。 它们是 “./cart” 和 “./inventory” 代表的模块。</p>

            <p>当 my/cart 和 my/inventory 模块加载后，定义函数接收到 “cart” 和 “inventory” 模块参数后，定义函数才会被调用。</p>

            <p>明确不鼓励在模块中定义全局变量，这样一个模块的多个版本才可以同时存在于页面中（参见 <strong>高阶使用</strong>）。同时，函数的参数顺序也应与依赖顺序保持一致。</p>

            <p>定义函数返回的对象定义了 “my/shirt” 模块。通过这样的形式定义 “my/shirt”，避免了全局对象的出现。</p>
        </div>

        <div class="subSection">
            <h4><a href="#funcmodule" name="funcmodule">定义模块为函数</a><span class="sectionMark">§ 1.3.4</span></h4>

            <p>模块不一定要返回对象，任何有效的函数返回值都是允许的。下面这个模块返回一个函数作为它的模块定义：</p>

            <pre><code class="javascript"><span class="comment">// foo/title.js 中的模块定义。</span>
<span class="comment">// 它使用前面的 my/cart 和 my/inventory 模块，</span>
<span class="comment">// 但因为 foo/title.js 处在与 “my” 模块不同的目录，</span>
<span class="comment">// 它在模块依赖名中使用 “my” 来寻找它们。</span>
<span class="comment">// 依赖名中的 “my” 部分可以映射到任何目录，</span>
<span class="comment">// 但默认地，被指定为与 “foo” 同级的目录。</span>
define([<span class="string">"my/cart"</span>, <span class="string">"my/inventory"</span>],
    <span class="function"><span class="keyword">function</span><span class="params">(cart, inventory)</span> {</span>
        <span class="comment">// 返回一个函数来定义 “foo/title”。</span>
        <span class="comment">// 它获取或设置窗口标题。</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(title)</span> {</span>
            <span class="keyword">return</span> title ? (window.title = title) :
                   inventory.storeName + <span class="string">' '</span> + cart.name;
        }
    }
);
</code></pre>
        </div>

        <div class="subSection">
            <h4><a href="#cjsmodule" name="cjsmodule">使用简化的 CommonJS 包装器定义模块</a><span class="sectionMark">§ 1.3.5</span></h4>

            <p>如果希望复用一些传统的 <a href="http://wiki.commonjs.org/wiki/Modules/1.1.1">CommonJS 模块格式</a>的代码，上面使用依赖数组的方式可能很难工作，你也许更愿意将依赖名对应到局部变量来使用依赖项。你可以使用<a href="commonjs.html">简化的 CommonJS 包装器</a>来处理这种情况：</p>


            <pre><code class="javascript">define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span> {</span>
        <span class="keyword">var</span> a = require(<span class="string">'a'</span>),
            b = require(<span class="string">'b'</span>);

        <span class="comment">// 返回模块的值</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
    }
);
</code></pre>

            <p>这个包装器依靠 Function.prototype.toString() 给出函数内容有用的字符串值。 这个方法在 PS3 等设备，以及旧版 Opera 移动浏览器上不起作用。可以使用 <a href="optimization.html">优化工具</a> 将依赖抽离成依赖数组的形式，来支持那些设备的使用。</p>

            <p>更多信息在 <a href="commonjs.html">CommonJS 页面</a>，以及 <a href="whyamd.html#sugar">Why AMD 页面的 “Sugar” 一节</a>.
            </p>
        </div>

        <div class="subSection">
            <h4><a href="#modulename" name="modulename">定义命名模块</a><span class="sectionMark">§ 1.3.6</span></h4>

            <p>你也许看到一些 define() 的调用包含一个模块名称作为第一个参数：</p>

            <pre><code class="javascript">    <span class="comment">// 明确地定义 “foo/title” 模块：</span>
    define(<span class="string">"foo/title"</span>,
        [<span class="string">"my/cart"</span>, <span class="string">"my/inventory"</span>],
        <span class="function"><span class="keyword">function</span><span class="params">(cart, inventory)</span> {</span>
            <span class="comment">// 此处定义 foo/title 对象。</span>
       }
    );
</code></pre>

            <p>这通常是由<a href="optimization.html">优化工具</a>生成的。你可以显式地对模块进行命名，但会降低模块的可移植性——如果把文件移到其他目录，你需要手动地修改模块名。通常最好避免硬编码模块名称，让优化工具来做就好了。优化工具可以来添加名称，因此可以打包多个模块到一个文件，这样可以在浏览器中更快地加载。</p>
        </div>

        <div class="subSection">

            <h4><a href="#modulenotes" name="modulenotes">其他注意事项</a><span class="sectionMark">§ 1.3.7</span></h4>

            <p id="modulenotes-onemodule"><strong>一个文件一个模块</strong>：每个 Javascript 文件应该只定义一个模块，遵循模块“名称-文件路径”查找算法的机制。多个模块可以被<a href="optimization.html">优化工具</a>合并到一个文件中，但是你应该仅使用优化工具来合并文件。</p>

            <p id="modulenotes-relative"><strong>define()中的相对模块名</strong>：为了在 define() 中可以使用 require("./relative/name")，要确保 “require” 作为一个依赖项，这样相对名称可以正确地得到解析：</p>

            <pre><code class="javascript">define([<span class="string">"require"</span>, <span class="string">"./relative/name"</span>], <span class="function"><span class="keyword">function</span><span class="params">(require)</span> {</span>
    <span class="keyword">var</span> mod = require(<span class="string">"./relative/name"</span>);
});
</code></pre>

            <p>或者更好地，使用为了支持<a href="commonjs.html">转换 CommonJS</a> 模块的简短语法：</p>

            <pre><code class="javascript">define(<span class="function"><span class="keyword">function</span><span class="params">(require)</span> {</span>
    <span class="keyword">var</span> mod = require(<span class="string">"./relative/name"</span>);
});
</code></pre>

            <p>这种形式会使用 Function.prototype.toString() 来寻找 require() 的调用，然后将它们与 “require” 一起添加到依赖数组，这样就可以正确地解析相对路径了。</p>

            <p>如果你正在同一目录创建多个模块，相对路径的方式会非常实用，你可以将目录分享给其他人或者项目，还可以获取目录中其他模块的引用，而不需知道当前目录的名称。</p>

            <p id="modulenotes-urls"><strong>生成相对于模块的URL</strong>：你可能需要生成一个相对于模块的URL，可以将 “require” 作为依赖项，然后使用 require.toUrl() 来生成 URL：</p>

            <pre><code class="javascript">define([<span class="string">"require"</span>], <span class="function"><span class="keyword">function</span><span class="params">(require)</span> {</span>
    <span class="keyword">var</span> cssUrl = require.toUrl(<span class="string">"./style.css"</span>);
});
</code></pre>

            <p id="modulenotes-console"><strong>控制台调试</strong>：如果你要在 JavaScript 控制台使用已经通过 require(["module/name"], function(){}) 加载完成的模块，你可以用 require() 的形式直接通过模块名来获取它：</p>

            <pre><code class="javascript">require(<span class="string">"module/name"</span>).callSomeFunction()
</code></pre>

            <p>注意，这只会在 "module/name" 已经先前通过 require(["module/name"]) 异步地加载到本地才会奏效。如果使用了相对路径，如 './module/name'，那么只会在 define 中有效。</p>
        </div>

        <div class="subSection">
            <h4><a href="#circular" name="circular">循环依赖</a><span class="sectionMark">§ 1.3.8</span></h4>

            <p>如果定义了循环依赖（a需要b b需要a），那么在此情况下，当 b 的模块定义函数调用时，它获取到的 a 值将是一个 undefined。b 可以晚些在模块定义后，使用 require() 方法来再次获取 a （保证指定 require 作为一个依赖项，来使用正确的上下文环境查找 a）：</p>

            <pre><code class="javascript"><span class="comment">// b.js 中:</span>
define([<span class="string">"require"</span>, <span class="string">"a"</span>],
    <span class="function"><span class="keyword">function</span><span class="params">(require, a)</span> {</span>
        <span class="comment">// 如果 a 也依赖 b，这种情形下 "a" 会是个空值，</span>
        <span class="comment">// 一个循环依赖。</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(title)</span> {</span>
            <span class="keyword">return</span> require(<span class="string">"a"</span>).doSomething();
        }
    }
);
</code></pre>

            <p>正常情况下，是不应该使用 require() 来加载模块的，而应依赖传入定义函数的参数。循环依赖非常少见，而且通常预示着应该重新思考设计的思路。但是，有时必须这么做，在这种情况下，要使用上述指定的 require() 方法。</p>

            <p>如果你熟悉 CommonJS 模块，可以用 <strong>exports</strong> 为模块创建一个空对象，可以立即被其他模块所引用。在循环引用的双方都这么做，就可以安全地引用双方模块。这只会在双方都 export 一个对象而不是函数时有效：</p>

            <pre><code class="javascript"><span class="comment">// b.js中:</span>
define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span> {</span>
    <span class="comment">// 如果 "a" 使用了 exports，我们就有一个真实的引用对象了。</span>
    <span class="comment">// 但是，直到 b 返回一个值之前，我们都不能访问 a 的任一属性。</span>
    <span class="keyword">var</span> a = require(<span class="string">"a"</span>);

    exports.foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> a.bar();
    };
});
</code></pre>

            <p>如果你在使用依赖数组的方式，请引用特殊的
                <a href="https://github.com/jrburke/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#wiki-magic">'exports' 依赖:</a>
            </p>

            <pre><code class="javascript"><span class="comment">// b.js中:</span>
define([<span class="string">'a'</span>, <span class="string">'exports'</span>], <span class="function"><span class="keyword">function</span><span class="params">(a, exports)</span> {</span>
    <span class="comment">// 如果 "a" 使用了 exports，我们就有一个真实的引用对象了。</span>
    <span class="comment">// 但是，直到 b 返回一个值之前，我们都不能访问 a 的任一属性。</span>

    exports.foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> a.bar();
    };
});
</code></pre>

        </div>

        <div class="subSection">
            <h4><a href="#jsonp" name="jsonp">指定 JSONP 服务依赖</a><span class="sectionMark">§ 1.3.9</span></h4>

            <p><a href="http://en.wikipedia.org/wiki/JSON#JSONP">JSONP</a> 是 JavaScript 中一种调用服务的方式。它是一种常用的跨域调用服务的方式，原理仅仅是通过 script 标签发起一个HTTP GET请求。</p>

            <p>要在 RequireJS 中使用 JSONP 服务，需要将 "define" 指定为回调参数的值。也就是说可以像一个模块定义的方式来获取 JSONP URL 的值。
            <pre><code class="javascript">require([<span class="string">"http://example.com/api/data.json?callback=define"</span>],
    <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
        <span class="comment">// data 对象是 JSONP 调用 API 的返回值。</span>
        console.log(data);
    }
);
</code></pre>

            <p>应用初始化时的 JSONP 服务应该限制这种 JSONP 的用法。一旦如果 JSONP 服务超时了，其他通过 define() 定义的模块可能也无法执行，因此这里的错误处理并不是很健壮。</p>

            <p><strong>Only JSONP return values that are JSON objects are supported</strong>. A JSONP response that is an array, a string or a number will not work.</p>

            <p>This functionality should not be used for long-polling JSONP connections -- APIs that deal with real time streaming. Those kinds of APIs should do more script cleanup after receiving each response, and RequireJS will only fetch a JSONP URL once -- subsequent uses of the same URL as a dependency in a require() or define() call will get a cached value.</p>

            <p>Errors in loading a JSONP service are normally surfaced via timeouts for the service, since script tag loading does not give much detail into network problems. To detect errors, you can override requirejs.onError() to get errors. There is more information in the <a href="#errors">Handling Errors</a> section.</p>

        </div>

        <div class="subSection">
            <h4><a href="#undef" name="undef">Undefining a Module</a><span class="sectionMark">§ 1.3.10</span></h4>

            <p>There is a global function, <b>requirejs.undef()</b>, that allows undefining a module. It will reset the loader's internal state to forget about the previous definition of the module.</p>

            <p><b>However</b>, it will not remove the module from other modules that are already defined and got a handle on that module as a dependency when they executed. So it is really only useful to use in error situations when no other modules have gotten a handle on a module value, or as part of any future module loading that may use that module. See the <a href="#errbacks">errback section</a> for an example.</p>

            <p>If you want to do more sophisticated dependency graph analysis for undefining work, the semi-private
                <a href="https://github.com/jrburke/requirejs/wiki/Internal-API:-onResourceLoad">onResourceLoad API</a> may be helpful.</p>

        </div>

        <p></p>
    </div>
    <p></p>

    <div class="section">
        <h2>
<a href="#mechanics" name="mechanics">Mechanics</a>
<span class="sectionMark">§ 2</span>
</h2>

        <p>RequireJS loads each dependency as a script tag, using head.appendChild().</p>

        <p>RequireJS waits for all dependencies to load, figures out the right order in which to call the functions that define the modules, then calls the module definition functions in the right order.</p>

        <p>Using RequireJS in a server-side JavaScript environment that has synchronous loading should be as easy as redefining require.load(). The build system does this, the require.load method for that environment can be found in build/jslib/requirePatch.js.</p>

        <p>In the future, this code may be pulled into the require/ directory as an optional module that you can load in your env to get the right load behavior based on the host environment.</p>
    </div>

    <div class="section">
        <h2>
<a href="#config" name="config">Configuration Options</a>
<span class="sectionMark">§ 3</span>
</h2>

        <p>When using require() in the top-level HTML page (or top-level script file that does not define a module), a configuration object can be passed as the first option:</p>

        <pre><code class="html"><span class="tag">&lt;<span class="keyword">script</span><span class="attribute"> src=<span class="value">"scripts/require.js"</span></span>&gt;</span><span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
<span class="tag">&lt;<span class="keyword">script</span>&gt;</span>
  require.config({
    baseUrl: "/another/path",
    paths: {
        "some": "some/v1.0"
    },
    waitSeconds: 15
  });
  require( ["some/module", "my/module", "a.js", "b.js"],
    function(someModule,    myModule) {
        //This function will be called when all the dependencies
        //listed above are loaded. Note that this function could
        //be called before the page is loaded.
        //This callback is optional.
    }
  );
<span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
</code></pre>

        <p>You may also call require.config from your <a href="api.html#data-main">data-main Entry Point</a>, but be aware that the data-main script is loaded asynchronously. Avoid other entry point scripts which wrongly assume that data-main and its require.config will always execute prior to their script loading.

        </p>
        <p>Also, you can define the config object as the global variable <code>require</code>  <strong>before</strong> require.js is loaded, and have the values applied automatically. This example specifies some dependencies to load as soon as require.js defines require():</p>

        <pre><code class="html"><span class="tag">&lt;<span class="keyword">script</span>&gt;</span>
    var require = {
        deps: ["some/module1", "my/module2", "a.js", "b.js"],
        callback: function(module1, module2) {
            //This function will be called when all the dependencies
            //listed above in deps are loaded. Note that this
            //function could be called before the page is loaded.
            //This callback is optional.
        }
    };
<span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
<span class="tag">&lt;<span class="keyword">script</span><span class="attribute"> src=<span class="value">"scripts/require.js"</span></span>&gt;</span><span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
</code></pre>

        <p><b>Note:</b> It is best to use <code>var require = {}</code> and do not use
            <code>window.require = {}</code>, it will not behave correctly in IE.</p>

        <p>Supported configuration options:</p>

        <p id="config-baseUrl"><strong><a href="#config-baseUrl">baseUrl</a></strong>: the root path to use for all module lookups. So in the above example, "my/module"'s script tag will have a src="/another/path/my/module.js". baseUrl is <strong>not</strong> used when loading plain .js files (indicated by a dependency string <a href="#jsfiles">starting with a slash, has a protocol, or ends in .js</a>), those strings are used as-is, so a.js and b.js will be loaded from the same directory as the HTML page that contains the above snippet.</p>

        <p>If no baseUrl is explicitly set in the configuration, the default value will be the location of the HTML page that loads require.js. If a <strong>data-main</strong> attribute is used, that path will become the baseUrl.</p>

        <p>The baseUrl can be a URL on a different domain as the page that will load require.js. RequireJS script loading works across domains. The only restriction is on text content loaded by text! plugins: those paths should be on the same domain as the page, at least during development. The optimization tool will inline text! plugin resources so after using the optimization tool, you can use resources that reference text! plugin resources from another domain.</p>

        <p id="config-paths"><strong><a href="#config-paths">paths</a></strong>: path mappings for module names not found directly under baseUrl. The path settings are assumed to be relative to baseUrl, unless the paths setting starts with a "/" or has a URL protocol in it ("like http:"). Using the above sample config, "some/module"'s script tag will be src="/another/path/some/v1.0/module.js".</p>

        <p>The path that is used for a module name should <strong>not</strong> include an extension, since the path mapping could be for a directory. The path mapping code will automatically add the .js extension when mapping the module name to a path. If <a href="#modulenotes-urls">require.toUrl()</a> is used, it will add the appropriate extension, if it is for something like a text template.</p>

        <p>When run in a browser, <a href="#pathsfallbacks">paths fallbacks</a> can be specified, to allow trying a load from a CDN location, but falling back to a local location if the CDN location fails to load.</p>

        <p id="config-bundles"><strong><a href="#config-bundles">bundles</a></strong>: Introduced in RequireJS 2.1.10: allows configuring multiple module IDs to be found in another script. Example:</p>

        <pre><code class="javascript">requirejs.config({
    bundles: {
        <span class="string">'primary'</span>: [<span class="string">'main'</span>, <span class="string">'util'</span>, <span class="string">'text'</span>, <span class="string">'text!template.html'</span>],
        <span class="string">'secondary'</span>: [<span class="string">'text!secondary.html'</span>]
    }
});

require([<span class="string">'util'</span>, <span class="string">'text'</span>], <span class="function"><span class="keyword">function</span><span class="params">(util, text)</span> {</span>
    <span class="comment">//The script for module ID 'primary' was loaded,</span>
    <span class="comment">//and that script included the define()'d</span>
    <span class="comment">//modules for 'util' and 'text'</span>
});
</code></pre>

        <p>That config states: modules 'main', 'util', 'text' and 'text!template.html' will be found by loading module ID 'primary'. Module 'text!secondary.html' can be found by loading module ID 'secondary'.
        </p>

        <p>This only sets up where to find a module inside a script that has multiple define()'d modules in it. It does not automatically bind those modules to the bundle's module ID. The bundle's module ID is just used for locating the set of modules.</p>

        <p>Something similar is possible with paths config, but it is much wordier, and the paths config route does not allow loader plugin resource IDs in its configuration, since the paths config values are path segments, not IDs.</p>

        <p>bundles config is useful if doing a build and that build target was not an existing module ID, or if you have loader plugin resources in built JS files that should not be loaded by the loader plugin. <strong>Note that the keys and values are module IDs</strong>, not path segments. They are absolute module IDs, not a module ID prefix like <a href="#config-paths">paths config</a> or <a href="#config-map">map config</a>. Also, bundle config is different from map config in that map config is a one-to-one module ID relationship, where bundle config is for pointing multiple module IDs to a bundle's module ID.</p>

        <p id="config-shim"><strong><a href="#config-shim">shim</a></strong>: Configure the dependencies, exports, and custom initialization for older, traditional "browser globals" scripts that do not use define() to declare the dependencies and set a module value.</p>

        <p>Here is an example. It requires RequireJS 2.1.0+, and assumes backbone.js, underscore.js and jquery.js have been installed in the baseUrl directory. If not, then you may need to set a paths config for them:</p>

        <pre><code class="javascript">requirejs.config({
    <span class="comment">//Remember: only use shim config for non-AMD scripts,</span>
    <span class="comment">//scripts that do not already call define(). The shim</span>
    <span class="comment">//config will not work correctly if used on AMD scripts,</span>
    <span class="comment">//in particular, the exports and init config will not</span>
    <span class="comment">//be triggered, and the deps config will be confusing</span>
    <span class="comment">//for those cases.</span>
    shim: {
        <span class="string">'backbone'</span>: {
            <span class="comment">//These script dependencies should be loaded before loading</span>
            <span class="comment">//backbone.js</span>
            deps: [<span class="string">'underscore'</span>, <span class="string">'jquery'</span>],
            <span class="comment">//Once loaded, use the global 'Backbone' as the</span>
            <span class="comment">//module value.</span>
            exports: <span class="string">'Backbone'</span>
        },
        <span class="string">'underscore'</span>: {
            exports: <span class="string">'_'</span>
        },
        <span class="string">'foo'</span>: {
            deps: [<span class="string">'bar'</span>],
            exports: <span class="string">'Foo'</span>,
            init: <span class="function"><span class="keyword">function</span> <span class="params">(bar)</span> {</span>
                <span class="comment">//Using a function allows you to call noConflict for</span>
                <span class="comment">//libraries that support it, and do other cleanup.</span>
                <span class="comment">//However, plugins for those libraries may still want</span>
                <span class="comment">//a global. "this" for the function will be the global</span>
                <span class="comment">//object. The dependencies will be passed in as</span>
                <span class="comment">//function arguments. If this function returns a value,</span>
                <span class="comment">//then that value is used as the module export value</span>
                <span class="comment">//instead of the object found via the 'exports' string.</span>
                <span class="comment">//Note: jQuery registers as an AMD module via define(),</span>
                <span class="comment">//so this will not work for jQuery. See notes section</span>
                <span class="comment">//below for an approach for jQuery.</span>
                <span class="keyword">return</span> <span class="keyword">this</span>.Foo.noConflict();
            }
        }
    }
});

<span class="comment">//Then, later in a separate file, call it 'MyModel.js', a module is</span>
<span class="comment">//defined, specifying 'backbone' as a dependency. RequireJS will use</span>
<span class="comment">//the shim config to properly load 'backbone' and give a local</span>
<span class="comment">//reference to this module. The global Backbone will still exist on</span>
<span class="comment">//the page too.</span>
define([<span class="string">'backbone'</span>], <span class="function"><span class="keyword">function</span> <span class="params">(Backbone)</span> {</span>
  <span class="keyword">return</span> Backbone.Model.extend({});
});
</code></pre>

        <p>In RequireJS 2.0.*, the "exports" property in the shim config could have been a function instead of a string. In that case, it functioned the same as the "init" property as shown above. The "init" pattern is used in RequireJS 2.1.0+ so a string value for <code>exports</code> can be used for
            <a href="#config-enforceDefine">enforceDefine</a>, but then allow functional work once the library is known to have loaded.</p>

        <p>For "modules" that are just jQuery or Backbone plugins that do not need to export any module value, the shim config can just be an array of dependencies:</p>

        <pre><code class="javascript">requirejs.config({
    shim: {
        <span class="string">'jquery.colorize'</span>: [<span class="string">'jquery'</span>],
        <span class="string">'jquery.scroll'</span>: [<span class="string">'jquery'</span>],
        <span class="string">'backbone.layoutmanager'</span>: [<span class="string">'backbone'</span>]
    }
});
</code></pre>

        <p>Note however if you want to get 404 load detection in IE so that you can use paths fallbacks or errbacks, then a string exports value should be given so the loader can check if the scripts actually loaded (a return from init is <strong>not</strong> used for <code>enforceDefine</code> checking):</p>

        <pre><code class="javascript">requirejs.config({
    shim: {
        <span class="string">'jquery.colorize'</span>: {
            deps: [<span class="string">'jquery'</span>],
            exports: <span class="string">'jQuery.fn.colorize'</span>
        },
        <span class="string">'jquery.scroll'</span>: {
            deps: [<span class="string">'jquery'</span>],
            exports: <span class="string">'jQuery.fn.scroll'</span>
        },
        <span class="string">'backbone.layoutmanager'</span>: {
            deps: [<span class="string">'backbone'</span>]
            exports: <span class="string">'Backbone.LayoutManager'</span>
        }
    }
});
</code></pre>

        <p><b>Important notes for "shim" config:</b>
        </p>

        <ul>
            <li>The shim config only sets up code relationships. To load modules that are part of or use shim config, a normal require/define call is needed. Setting shim by itself does not trigger code to load.</li>
            <li>Only use other "shim" modules as dependencies for shimmed scripts, or AMD libraries that have no dependencies and call define() after they also create a global (like jQuery or lodash). Otherwise, if you use an AMD module as a dependency for a shim config module, after a build, that AMD module may not be evaluated until after the shimmed code in the build executes, and an error will occur. The ultimate fix is to upgrade all the shimmed code to have optional AMD define() calls.</li>
            <li>If it is not possible to upgrade the shimmed code to use AMD define() calls, as of RequireJS 2.1.11, the optimizer has a
                <a href="https://github.com/jrburke/r.js/blob/b8a6982d2923ae8389355edaa50d2b7f8065a01a/build/example.build.js#L68">wrapShim build option</a> that will try to automatically wrap the shimmed code in a define() for a build. This changes the scope of shimmed dependencies, so it is not guaranteed to always work, but, for example, for shimmed dependencies that depend on an AMD version of Backbone, it can be helpful.</li>
            <li>The init function will <strong>not</strong> be called for AMD modules. For example, you cannot use a shim init function to call jQuery's noConflict. See <a href="jquery.html#noconflictmap">Mapping Modules to use noConflict</a>
                for an alternate approach to jQuery.</li>
            <li>Shim config is not supported when running AMD modules in node via RequireJS (it works for optimizer use though). Depending on the module being shimmed, it may fail in Node because Node does not have the same global environment as browsers. As of RequireJS 2.1.7, it will warn you in the console that shim config is not supported, and it may or may not work. If you wish to suppress that message, you can pass <code>requirejs.config({ suppress: { nodeShim: true }});</code>.</li>
        </ul>

        <p><b>Important optimizer notes for "shim" config</b>:</p>

        <ul>
            <li>You should use the <a href="optimization.html#mainConfigFile">mainConfigFile build option</a> to specify the file where to find the shim config. Otherwise the optimizer will not know of the shim config. The other option is to duplicate the shim config in the build profile.</li>
            <li>Do not mix CDN loading with shim config in a build. Example scenario: you load jQuery from the CDN but use the shim config to load something like the stock version of Backbone that depends on jQuery. When you do the build, be sure to inline jQuery in the built file and do not load it from the CDN. Otherwise, Backbone will be inlined in the built file and it will execute before the CDN-loaded jQuery will load. This is because the shim config just delays loading of the files until dependencies are loaded, but does not do any auto-wrapping of define. After a build, the dependencies are already inlined, the shim config cannot delay execution of the non-define()'d code until later. define()'d modules do work with CDN loaded code after a build because they properly wrap their source in define factory function that will not execute until dependencies are loaded. So the lesson: shim config is a stop-gap measure for non-modular code, legacy code. define()'d modules are better.</li>
            <li>For local, multi-file builds, the above CDN advice also applies. For any shimmed script, its dependencies <strong>must</strong> be loaded before the shimmed script executes. This means either building its dependencies directly in the buid layer that includes the shimmed script, or loading its dependencies with a <code>require([], function (){})</code> call, then doing a nested <code>require([])</code> call for the build layer that has the shimmed script.</li>
            <li>If you are using uglifyjs to minify the code, <strong>do not</strong> set the uglify option <code>toplevel</code> to true, or if using the command line
                <strong>do not</strong> pass <code>-mt</code>. That option mangles the global names that shim uses to find exports.</li>
        </ul>

        <p id="config-map"><strong><a href="#config-map">map</a></strong>: For the given module prefix, instead of loading the module with the given ID, substitute a different module ID.</p>

        <p>This sort of capability is really important for larger projects which may have two sets of modules that need to use two different versions of 'foo', but they still need to cooperate with each other.</p>

        <p>This is not possible with the <a href="#multiversion">context-backed multiversion support</a>. In addition, the <a href="#config-paths">paths config</a> is only for setting up root paths for module IDs, not for mapping one module ID to another one.</p>

        <p>map example:</p>

        <pre><code class="javascript">requirejs.config({
    map: {
        <span class="string">'some/newmodule'</span>: {
            <span class="string">'foo'</span>: <span class="string">'foo1.2'</span>
        },
        <span class="string">'some/oldmodule'</span>: {
            <span class="string">'foo'</span>: <span class="string">'foo1.0'</span>
        }
    }
});
</code></pre>

        <p>If the modules are laid out on disk like this:</p>

        <ul>
            <li>foo1.0.js</li>
            <li>foo1.2.js</li>
            <li>some/
                <ul>
                    <li>newmodule.js</li>
                    <li>oldmodule.js</li>
                </ul>
            </li>
        </ul>

        <p>When 'some/newmodule' does `require('foo')` it will get the foo1.2.js file, and when 'some/oldmodule' does `require('foo')` it will get the foo1.0.js file.</p>

        <p>This feature only works well for scripts that are real AMD modules that call define() and register as anonymous modules. Also, <strong>only use absolute module IDs</strong> for map config. Relative IDs (like <code>'../some/thing'</code>) do not work.</p>

        <p>There is also support for a "*" map value which means "for all modules loaded, use this map config". If there is a more specific map config, that one will take precedence over the star config. Example:</p>

        <pre><code class="javascript">
requirejs.config({
    map: {
        <span class="string">'*'</span>: {
            <span class="string">'foo'</span>: <span class="string">'foo1.2'</span>
        },
        <span class="string">'some/oldmodule'</span>: {
            <span class="string">'foo'</span>: <span class="string">'foo1.0'</span>
        }
    }
});
</code></pre>

        <p>Means that for any module except "some/oldmodule", when "foo" is wanted, use "foo1.2" instead. For "some/oldmodule" only, use "foo1.0" when it asks for "foo".</p>

        <p id="config-moduleconfig"><strong><a href="#config-moduleconfig">config</a></strong>: There is a common need to pass configuration info to a module. That configuration info is usually known as part of the application, and there needs to be a way to pass that down to a module. In RequireJS, that is done with the <b>config</b> option for requirejs.config(). Modules can then read that info by asking for the special dependency "module" and calling <b>module.config()</b>. Example:</p>

        <pre><code class="javascript">requirejs.config({
    config: {
        <span class="string">'bar'</span>: {
            size: <span class="string">'large'</span>
        },
        <span class="string">'baz'</span>: {
            color: <span class="string">'blue'</span>
        }
    }
});

<span class="comment">//bar.js, which uses simplified CJS wrapping:</span>
<span class="comment">//http://requirejs.org/docs/whyamd.html#sugar</span>
define(<span class="function"><span class="keyword">function</span> <span class="params">(require, exports, module)</span> {</span>
    <span class="comment">//Will be the value 'large'</span>
    <span class="keyword">var</span> size = module.config().size;
});

<span class="comment">//baz.js which uses a dependency array,</span>
<span class="comment">//it asks for the special module ID, 'module':</span>
<span class="comment">//https://github.com/jrburke/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#wiki-magic</span>
define([<span class="string">'module'</span>], <span class="function"><span class="keyword">function</span> <span class="params">(module)</span> {</span>
    <span class="comment">//Will be the value 'blue'</span>
    <span class="keyword">var</span> color = module.config().color;
});
</code></pre>

        <p>For passing config to a <a href="#packages">package</a>, target the main module in the package, not the package ID:</p>

        <pre><code class="javascript">requirejs.config({
    <span class="comment">//Pass an API key for use in the pixie package's</span>
    <span class="comment">//main module.</span>
    config: {
        <span class="string">'pixie/index'</span>: {
            apiKey: <span class="string">'XJKDLNS'</span>
        }
    },
    <span class="comment">//Set up config for the "pixie" package, whose main</span>
    <span class="comment">//module is the index.js file in the pixie folder.</span>
    packages: [
        {
            name: <span class="string">'pixie'</span>,
            main: <span class="string">'index'</span>
        }
    ]
});
</code></pre>

        <p id="config-packages"><strong><a href="#config-packages">packages</a></strong>: configures loading modules from CommonJS packages. See the <a href="#packages">packages topic</a> for more information.</p>

        <p id="config-nodeIdCompat"><strong><a href="#config-nodeIdCompat">nodeIdCompat</a></strong>: Node treats module ID <code>example.js</code> and <code>example</code> the same. By default these are two different IDs in RequireJS. If you end up using modules installed from npm, then you may need to set this config value to <code>true</code> to avoid resolution issues.</p>

        <p id="config-waitSeconds"><strong><a href="#config-waitSeconds">waitSeconds</a></strong>: The number of seconds to wait before giving up on loading a script. Setting it to 0 disables the timeout. The default is 7 seconds.</p>

        <p id="config-context"><strong><a href="#config-context">context</a></strong>: A name to give to a loading context. This allows require.js to load multiple versions of modules in a page, as long as each top-level require call specifies a unique context string. To use it correctly, see the <a href="#multiversion">Multiversion Support</a> section.</p>

        <p id="config-deps"><strong><a href="#config-deps">deps</a></strong>: An array of dependencies to load. Useful when require is defined as a config object before require.js is loaded, and you want to specify dependencies to load as soon as require() is defined. Using deps is just like doing a <code>require([])</code> call, but done as soon as the loader has processed the configuration. <strong>It does not block</strong>
            any other require() calls from starting their requests for modules, it is just a way to specify some modules to load asynchronously as part of a config block.</p>

        <p id="config-callback"><strong><a href="#config-callback">callback</a></strong>: A function to execute after <strong>deps</strong> have been loaded. Useful when require is defined as a config object before require.js is loaded, and you want to specify a function to require after the configuration's <strong>deps</strong> array has been loaded.</p>

        <p id="config-enforceDefine"><strong><a href="#config-enforceDefine">enforceDefine</a></strong>: If set to true, an error will be thrown if a script loads that does not call define() or have a shim exports string value that can be checked. See <a href="#ieloadfail">Catching load failures in IE</a> for more information.</p>

        <p id="config-xhtml"><strong><a href="#config-xhtml">xhtml</a></strong>: If set to true, document.createElementNS() will be used to create script elements.</p>

        <p id="config-urlArgs"><strong><a href="#config-urlArgs">urlArgs</a></strong>: Extra query string arguments appended to URLs that RequireJS uses to fetch resources. Most useful to cache bust when the browser or server is not configured correctly. Example cache bust setting for urlArgs:</p>

        <pre><code class="javascript">urlArgs: <span class="string">"bust="</span> +  (<span class="keyword">new</span> Date()).getTime()
</code></pre>

        <p>During development it can be useful to use this, however <strong>be sure</strong> to remove it before deploying your code.</p>

        <p id="config-scriptType"><strong><a href="#config-baseUrl">scriptType</a></strong>: Specify the value for the type="" attribute used for script tags inserted into the document by RequireJS. Default is "text/javascript". To use Firefox's JavaScript 1.8 features, use "text/javascript;version=1.8".</p>

        <p id="config-skipDataMain"><strong><a href="#config-skipDataMain">skipDataMain</a></strong>: Introduced in RequireJS 2.1.9: If set to <code>true</code>, skips the <a href="#data-main">data-main attribute scanning</a> done to start module loading. Useful if RequireJS is embedded in a utility library that may interact with other RequireJS library on the page, and the embedded version should not do data-main loading.</p>

    </div>

    <div class="section">
        <h2>
<a href="#advanced" name="advanced">Advanced Usage</a>
<span class="sectionMark">§ 4</span>
</h2>

        <h3><a href="#packages" name="packages">Loading Modules from Packages</a><span class="sectionMark">§ 4.1</span></h3>

        <p>RequireJS supports loading modules that are in a <a href="http://wiki.commonjs.org/wiki/Packages/1.1">CommonJS Packages</a> directory structure, but some additional configuration needs to be specified for it to work. Specifically, there is support for the following CommonJS Packages features:</p>

        <ul>
            <li>A package can be associated with a module name/prefix.</li>
            <li>The package config can specify the following properties for a specific package:
                <ul>
                    <li><strong>name</strong>: The name of the package (used for the module name/prefix mapping)</li>
                    <li><strong>location</strong>: The location on disk. Locations are relative to the baseUrl configuration value, unless they contain a protocol or start with a front slash (/).</li>
                    <li><strong>main</strong>: The name of the module inside the package that should be used when someone does a require for "packageName". The default value is "main", so only specify it if it differs from the default. The value is relative to the package folder.</li>
                </ul>
            </li>
        </ul>

        <p><strong>IMPORTANT NOTES</strong>
        </p>

        <ul>
            <li>While the packages can have the CommonJS directory layout, the modules themselves should be in a module format that RequireJS can understand. Exception to the rule: if you are using the r.js Node adapter, the modules can be in the traditional CommonJS module format. You can use the <a href="commonjs.html#autoconversion">CommonJS converter tool</a> if you need to convert traditional CommonJS modules into the async module format that RequireJS uses.</li>
            <li>Only one version of a package can be used in a project context at a time. You can use RequireJS <a href="#multiversion">multiversion support</a> to load two different module contexts, but if you want to use Package A and B in one context and they depend on different versions of Package C, then that will be a problem. This may change in the future.</li>
        </ul>

        <p>If you use a similar project layout as specified in the <a href="start.html">Start Guide</a>, the start of your web project would look something like this (Node/Rhino-based projects are similar, just use the contents of the <strong>scripts</strong> directory as the top-level project directory):</p>

        <ul>
            <li>project-directory/
                <ul>
                    <li>project.html</li>
                    <li>scripts/
                        <ul>
                            <li>require.js</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <p>Here is how the example directory layout looks with two packages, <strong>cart</strong> and <strong>store</strong>:</p>

        <ul>
            <li>project-directory/
                <ul>
                    <li>project.html</li>
                    <li>scripts/
                        <ul>
                            <li>cart/
                                <ul>
                                    <li>main.js</li>
                                </ul>
                            </li>
                            <li>store/
                                <ul>
                                    <li>main.js</li>
                                    <li>util.js</li>
                                </ul>
                            </li>
                            <li>main.js</li>
                            <li>require.js</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <p><strong>project.html</strong> will have a script tag like this:</p>

        <pre><code class="html"><span class="tag">&lt;<span class="keyword">script</span><span class="attribute"> data-main=<span class="value">"scripts/main"</span></span><span class="attribute"> src=<span class="value">"scripts/require.js"</span></span>&gt;</span><span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
</code></pre>

        <p>This will instruct require.js to load scripts/main.js. <strong>main.js</strong> uses the "packages" config to set up packages that are relative to require.js, which in this case are the source packages "cart" and "store":</p>

        <pre><code class="javascript"><span class="comment">//main.js contents</span>
<span class="comment">//Pass a config object to require</span>
require.config({
    <span class="string">"packages"</span>: [<span class="string">"cart"</span>, <span class="string">"store"</span>]
});

require([<span class="string">"cart"</span>, <span class="string">"store"</span>, <span class="string">"store/util"</span>],
<span class="function"><span class="keyword">function</span> <span class="params">(cart,   store,   util)</span> {</span>
    <span class="comment">//use the modules as usual.</span>
});
</code></pre>

        <p>A require of "cart" means that it will be loaded from <strong>scripts/cart/main.js</strong>, since "main" is the default main module setting supported by RequireJS. A require of "store/util" will be loaded from <strong>scripts/store/util.js</strong>.</p>

        <p>If the "store" package did not follow the "main.js" convention, and looked more like this:</p>

        <ul>
            <li>project-directory/
                <ul>
                    <li>project.html</li>
                    <li>scripts/
                        <ul>
                            <li>cart/
                                <ul>
                                    <li>main.js</li>
                                </ul>
                            </li>
                            <li>store/
                                <ul>
                                    <li>store.js</li>
                                    <li>util.js</li>
                                </ul>
                            </li>
                            <li>main.js</li>
                            <li>package.json</li>
                            <li>require.js</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <p>Then the RequireJS configuration would look like so:</p>

        <pre><code class="javascript">require.config({
    packages: [
        <span class="string">"cart"</span>,
        {
            name: <span class="string">"store"</span>,
            main: <span class="string">"store"</span>
        }
    ]
});
</code></pre>

        <p>To avoid verbosity, it is strongly suggested to always use packages that use "main" convention in their structure.</p>

        <h3><a href="#multiversion" name="multiversion">Multiversion Support</a><span class="sectionMark">§ 4.2</span></h3>

        <p>As mentioned in <a href="#config">Configuration Options</a>, multiple versions of a module can be loaded in a page by using different "context" configuration options. require.config() returns a require function that will use the context configuration. Here is an example that loads two different versions of the alpha and beta modules (this example is taken from one of the test files):</p>

        <pre><code class="html"><span class="tag">&lt;<span class="keyword">script</span><span class="attribute"> src=<span class="value">"../require.js"</span></span>&gt;</span><span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
<span class="tag">&lt;<span class="keyword">script</span>&gt;</span>
var reqOne = require.config({
  context: "version1",
  baseUrl: "version1"
});

reqOne(["require", "alpha", "beta",],
function(require,   alpha,   beta) {
  log("alpha version is: " + alpha.version); //prints 1
  log("beta version is: " + beta.version); //prints 1

  setTimeout(function() {
    require(["omega"],
      function(omega) {
        log("version1 omega loaded with version: " +
             omega.version); //prints 1
      }
    );
  }, 100);
});

var reqTwo = require.config({
      context: "version2",
      baseUrl: "version2"
    });

reqTwo(["require", "alpha", "beta"],
function(require,   alpha,   beta) {
  log("alpha version is: " + alpha.version); //prints 2
  log("beta version is: " + beta.version); //prints 2

  setTimeout(function() {
    require(["omega"],
      function(omega) {
        log("version2 omega loaded with version: " +
            omega.version); //prints 2
      }
    );
  }, 100);
});
<span class="tag">&lt;/<span class="keyword">script</span>&gt;</span>
</code></pre>

        <p>Note that "require" is specified as a dependency for the module. This allows the require() function that is passed to the function callback to use the right context to load the modules correctly for multiversion support. If "require" is not specified as a dependency, then there will likely be an error.</p>

        <h3><a href="#afterload" name="afterload">Loading Code After Page Load</a><span class="sectionMark">§ 4.3</span></h3>

        <p>The example above in the <strong>Multiversion Support</strong> section shows how code can later be loaded by nested require() calls.</p>

        <h3><a href="#webworker" name="webworker">Web Worker Support</a><span class="sectionMark">§ 4.4</span></h3>

        <p>As of release 0.12, RequireJS can be run inside a Web Worker. Just use importScripts() inside a web worker to load require.js (or the JS file that contains the require() definition), then call require.</p>

        <p>You will likely need to set the <strong>baseUrl</strong>  <a href="#config">configuration option</a> to make sure require() can find the scripts to load.</p>

        <p>You can see an example of its use by looking at one of the files used in <a href="http://github.com/jrburke/requirejs/blob/master/tests/workers.js">the unit test</a>.</p>

        <h3><a href="#rhino" name="rhino">Rhino Support</a><span class="sectionMark">§ 4.5</span></h3>

        <p>RequireJS can be used in Rhino via the <a href="download.html#rjs">r.js adapter</a>. See <a href="https://github.com/jrburke/r.js/blob/master/README.html">the r.js README</a> for more information.</p>

        <h3><a href="#errors" name="errors">Handling Errors</a><span class="sectionMark">§ 4.6</span></h3>

        <p>The general class of errors are 404s for scripts (not found), network timeouts or errors in the scripts that are loaded. RequireJS has a few tools to deal with them: require-specific errbacks, a "paths" array config, and a global requirejs.onError.</p>

        <p>The error object passed to errbacks and the global requirejs.onError function will usually contain two custom properties:</p>

        <ul>
            <li><strong>requireType</strong>: A string value with a general classification, like "timeout", "nodefine", "scripterror".</li>
            <li><strong>requireModules</strong>: an array of module names/URLs that timed out.</li>
        </ul>

        <p>If you get an error with a requireModules, it probably means other modules that depend on the modules in that requireModules array are not defined.</p>

        <h4>
<a href="#ieloadfail" name="ieloadfail">Catching load failures in IE</a>
<span class="sectionMark">§ 4.6.1</span>
</h4>

        <p>Internet Explorer has a set of problems that make it difficult to detect load failures for errbacks/paths fallbacks:</p>

        <ul>
            <li>script.onerror does not work in IE 6-8. There is no way to know if loading a script generates a 404, worse, it triggers the onreadystatechange with a complete state even in a 404 case.</li>
            <li>script.onerror does work in IE 9+, but it has a bug where it does not fire script.onload event handlers right after execution of script, so it cannot support the standard method of allowing anonymous AMD modules. So script.onreadystatechange is still used. However, onreadystatechange fires with a complete state before the script.onerror function fires.</li>
        </ul>

        <p>So it is very difficult with IE to allow both anonymous AMD modules, which are a core benefit of AMD modules, and reliable detect errors.</p>

        <p>However, if you are in a project that you know uses define() to declare all of its modules, or it uses the <a href="#config-shim">shim</a> config to specify string exports for anything that does not use define(), then if you set the <a href="#config-enforceDefine">enforceDefine</a> config value to true, the loader can confirm if a script load by checking for the define() call or the existence of the shim's exports global value.</p>

        <p>So if you want to support Internet Explorer, catch load errors, and have modular code either through direct define() calls or shim config, always set <b>enforceDefine</b> to be true. See the next section for an example.</p>

        <p><b>NOTE</b>: If you do set enforceDefine: true, and you use data-main="" to load your main JS module, then that main JS module <b>must call define()</b> instead of require() to load the code it needs. The main JS module can still call require/requirejs to set config values, but for loading modules it should use define().</p>

        <p>If you then also use <a href="https://github.com/jrburke/almond">almond</a> to build your code without require.js, be sure to use the <a href="https://github.com/jrburke/r.js/blob/master/build/example.build.js#L289">insertRequire</a> build setting to insert a require call for the main module -- that serves the same purpose of the initial require() call that data-main does.</p>

        <h4>
<a href="#errbacks" name="errbacks">require([]) errbacks</a>
<span class="sectionMark">§ 4.6.2</span>
</h4>

        <p>Errbacks, when used with <a href="#undef">requirejs.undef()</a>, will allow you to detect if a module fails to load, undefine that module, reset the config to a another location, then try again.</p>

        <p>A common use case for this is to use a CDN-hosted version of a library, but if that fails, switch to loading the file locally:</p>

        <pre><code class="javascript">requirejs.config({
    enforceDefine: <span class="literal">true</span>,
    paths: {
        jquery: <span class="string">'http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min'</span>
    }
});

<span class="comment">//Later</span>
require([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span> <span class="params">($)</span> {</span>
    <span class="comment">//Do something with $ here</span>
}, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    <span class="comment">//The errback, error callback</span>
    <span class="comment">//The error has a list of modules that failed</span>
    <span class="keyword">var</span> failedId = err.requireModules &amp;&amp; err.requireModules[<span class="number">0</span>];
    <span class="keyword">if</span> (failedId === <span class="string">'jquery'</span>) {
        <span class="comment">//undef is function only on the global requirejs object.</span>
        <span class="comment">//Use it to clear internal knowledge of jQuery. Any modules</span>
        <span class="comment">//that were dependent on jQuery and in the middle of loading</span>
        <span class="comment">//will not be loaded yet, they will wait until a valid jQuery</span>
        <span class="comment">//does load.</span>
        requirejs.undef(failedId);

        <span class="comment">//Set the path to jQuery to local path</span>
        requirejs.config({
            paths: {
                jquery: <span class="string">'local/jquery'</span>
            }
        });

        <span class="comment">//Try again. Note that the above require callback</span>
        <span class="comment">//with the "Do something with $ here" comment will</span>
        <span class="comment">//be called if this new attempt to load jQuery succeeds.</span>
        require([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>});
    } <span class="keyword">else</span> {
        <span class="comment">//Some other error. Maybe show message to the user.</span>
    }
});
</code></pre>

        <p>With `requirejs.undef()`, if you later set up a different config and try to load the same module, the loader will still remember which modules needed that dependency and finish loading them when the newly configured module loads.</p>

        <p><b>Note</b>: errbacks only work with callback-style require calls, not define() calls. define() is only for declaring modules.</p>

        <h4>
<a href="#pathsfallbacks" name="pathsfallbacks">paths config fallbacks</a>
<span class="sectionMark">§ 4.6.3</span>
</h4>

        <p>The above pattern for detecting a load failure, undef()ing a module, modifying paths and reloading is a common enough request that there is also a shorthand for it. The paths config allows array values:</p>

        <pre><code class="javascript">requirejs.config({
    <span class="comment">//To get timely, correct error triggers in IE, force a define/shim exports check.</span>
    enforceDefine: <span class="literal">true</span>,
    paths: {
        jquery: [
            <span class="string">'http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min'</span>,
            <span class="comment">//If the CDN location fails, load from this location</span>
            <span class="string">'lib/jquery'</span>
        ]
    }
});

<span class="comment">//Later</span>
require([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span> <span class="params">($)</span> {</span>
});
</code></pre>

        <p>This above code will try the CDN location, but if that fails, fall back to the local lib/jquery.js location.</p>

        <p><b>Note</b>: paths fallbacks only work for exact module ID matches. This is different from normal paths config which can apply to any part of a module ID prefix segment. Fallbacks are targeted more for unusual error recovery, not a generic path search path solution, since those are inefficient in the browser.</p>

        <h4>
<a href="#requirejsonerror" name="requirejsonerror">Global requirejs.onError function</a>
<span class="sectionMark">§ 4.6.4</span>
</h4>

        <p>To detect errors that are not caught by local errbacks, you can override requirejs.onError():</p>

        <pre><code class="javascript">requirejs.onError = <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    console.log(err.requireType);
    <span class="keyword">if</span> (err.requireType === <span class="string">'timeout'</span>) {
        console.log(<span class="string">'modules: '</span> + err.requireModules);
    }

    <span class="keyword">throw</span> err;
};
</code></pre>

    </div>

    <div class="section">
        <h2>
<a href="#plugins" name="plugins">Loader Plugins</a>
<span class="sectionMark">§ 5</span>
</h2>

        <p>RequireJS supports <a href="plugins.html">loader plugins</a>. This is a way to support dependencies that are not plain JS files, but are still important for a script to have loaded before it can do its work. The RequireJS wiki has <a href="https://github.com/jrburke/requirejs/wiki/Plugins">a list of plugins</a>. This section talks about some specific plugins that are maintained alongside RequireJS:</p>

        <h3><a href="#text" name="text">Specify a Text File Dependency</a><span class="sectionMark">§ 5.1</span></h3>

        <p>It is nice to build HTML using regular HTML tags, instead of building up DOM structures in script. However, there is no good way to embed HTML in a JavaScript file. The best that can be done is using a string of HTML, but that can be hard to manage, particularly for multi-line HTML.</p>

        <p>RequireJS has a plugin, text.js, that can help with this issue. It will automatically be loaded if the text! prefix is used for a dependency. See the
            <a href="https://github.com/requirejs/text">text.js README</a> for more information.</p>

        <h3><a href="#pageload" name="pageload">Page Load Event Support/DOM Ready</a><span class="sectionMark">§ 5.2</span></h3>

        <p>It is possible when using RequireJS to load scripts quickly enough that they complete before the DOM is ready. Any work that tries to interact with the DOM should wait for the DOM to be ready. For modern browsers, this is done by waiting for the DOMContentLoaded event.</p>

        <p>However, not all browsers in use support DOMContentLoaded. The domReady module implements a cross-browser method to determine when the DOM is ready. <a href="download.html#domReady">Download the module</a> and use it in your project like so:</p>

        <pre><code class="javascript">require([<span class="string">'domReady'</span>], <span class="function"><span class="keyword">function</span> <span class="params">(domReady)</span> {</span>
  domReady(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="comment">//This function is called once the DOM is ready.</span>
    <span class="comment">//It will be safe to query the DOM and manipulate</span>
    <span class="comment">//DOM nodes in this function.</span>
  });
});
</code></pre>

        <p>Since DOM ready is a common application need, ideally the nested functions in the API above could be avoided. The domReady module also implements the <a href="plugins.html">Loader Plugin API</a>, so you can use the loader plugin syntax (notice the <b>!</b> in the domReady dependency) to force the require() callback function to wait for the DOM to be ready before executing. domReady will return the current document when used as a loader plugin:</p>

        <pre><code class="javascript">require([<span class="string">'domReady!'</span>], <span class="function"><span class="keyword">function</span> <span class="params">(doc)</span> {</span>
    <span class="comment">//This function is called once the DOM is ready,</span>
    <span class="comment">//notice the value for 'domReady!' is the current</span>
    <span class="comment">//document.</span>
});
</code></pre>

        <p><b>Note:</b> If the document takes a while to load (maybe it is a very large document, or has HTML script tags loading large JS files that block DOM completion until they are done), using domReady as a loader plugin may result in a RequireJS "timeout" error. If this a problem either increase the <a href="#config-waitSeconds">waitSeconds</a> configuration, or just use domReady as a module and call domReady() inside the require() callback.</p>

        <h3><a href="#i18n" name="i18n">Define an I18N Bundle</a><span class="sectionMark">§ 5.3</span></h3>

        <p>Once your web app gets to a certain size and popularity, localizing the strings in the interface and providing other locale-specific information becomes more useful. However, it can be cumbersome to work out a scheme that scales well for supporting multiple locales.</p>

        <p>RequireJS allows you to set up a basic module that has localized information without forcing you to provide all locale-specific information up front. It can be added over time, and only strings/values that change between locales can be defined in the locale-specific file.</p>

        <p>i18n bundle support is provided by the i18n.js plugin. It is automatically loaded when a module or dependency specifies the i18n! prefix (more info below). <a href="download.html#i18n">Download the plugin</a> and put it in the same directory as your app's main JS file.</p>

        <p>To define a bundle, put it in a directory called "nls" -- the i18n! plugin assumes a module name with "nls" in it indicates an i18n bundle. The "nls" marker in the name tells the i18n plugin where to expect the locale directories (they should be immediate children of the nls directory). If you wanted to provide a bundle of color names in your "my" set of modules, create the directory structure like so:</p>

        <ul>
            <li>my/nls/colors.js</li>
        </ul>

        <p>The contents of that file should look like so:</p>

        <pre><code class="javascript"><span class="comment">//my/nls/colors.js contents:</span>
define({
    <span class="string">"root"</span>: {
        <span class="string">"red"</span>: <span class="string">"red"</span>,
        <span class="string">"blue"</span>: <span class="string">"blue"</span>,
        <span class="string">"green"</span>: <span class="string">"green"</span>
    }
});
</code></pre>

        <p>An object literal with a property of "root" defines this module. That is all you have to do to set the stage for later localization work.</p>

        <p>You can then use the above module in another module, say, in a my/lamps.js file:</p>

        <pre><code class="javascript"><span class="comment">//Contents of my/lamps.js</span>
define([<span class="string">"i18n!my/nls/colors"</span>], <span class="function"><span class="keyword">function</span><span class="params">(colors)</span> {</span>
    <span class="keyword">return</span> {
        testMessage: <span class="string">"The name for red in this locale is: "</span> + colors.red
    }
});
</code></pre>

        <p>The my/lamps module has one property called "testMessage" that uses colors.red to show the localized value for the color red.</p>

        <p>Later, when you want to add a specific translation to a file, say for the fr-fr locale, change my/nls/colors to look like so:</p>

        <pre><code class="javascript"><span class="comment">//Contents of my/nls/colors.js</span>
define({
    <span class="string">"root"</span>: {
        <span class="string">"red"</span>: <span class="string">"red"</span>,
        <span class="string">"blue"</span>: <span class="string">"blue"</span>,
        <span class="string">"green"</span>: <span class="string">"green"</span>
    },
    <span class="string">"fr-fr"</span>: <span class="literal">true</span>
});
</code></pre>

        <p>Then define a file at my/nls/fr-fr/colors.js that has the following contents:</p>

        <pre><code class="javascript"><span class="comment">//Contents of my/nls/fr-fr/colors.js</span>
define({
    <span class="string">"red"</span>: <span class="string">"rouge"</span>,
    <span class="string">"blue"</span>: <span class="string">"bleu"</span>,
    <span class="string">"green"</span>: <span class="string">"vert"</span>
});
</code></pre>

        <p>RequireJS will use the browser's navigator.language or navigator.userLanguage property to determine what locale values to use for my/nls/colors, so your app does not have to change. If you prefer to set the locale, you can use the <a href="#moduleconfig">module config</a> to pass the locale to the plugin:</p>

        <pre><code class="javascript">requirejs.config({
    config: {
        <span class="comment">//Set the config for the i18n</span>
        <span class="comment">//module ID</span>
        i18n: {
            locale: <span class="string">'fr-fr'</span>
        }
    }
});
</code></pre>

        <p><strong>Note</strong> that RequireJS will always use a lowercase version of the locale, to avoid case issues, so all of the directories and files on disk for i18n bundles should use lowercase locales.</p>

        <p>RequireJS is also smart enough to pick the right locale bundle, the one that most closely matches the ones provided by my/nls/colors. For instance, if the locale is "en-us", then the "root" bundle will be used. If the locale is "fr-fr-paris" then the "fr-fr" bundle will be used.</p>

        <p>RequireJS also combines bundles together, so for instance, if the french bundle was defined like so (omitting a value for red):</p>

        <pre><code class="javascript"><span class="comment">//Contents of my/nls/fr-fr/colors.js</span>
define({
    <span class="string">"blue"</span>: <span class="string">"bleu"</span>,
    <span class="string">"green"</span>: <span class="string">"vert"</span>
});
</code></pre>

        <p>Then the value for red in "root" will be used. This works for all locale pieces. If all the bundles listed below were defined, then RequireJS will use the values in the following priority order (the one at the top takes the most precedence):</p>

        <ul>
            <li>my/nls/fr-fr-paris/colors.js</li>
            <li>my/nls/fr-fr/colors.js</li>
            <li>my/nls/fr/colors.js</li>
            <li>my/nls/colors.js</li>
        </ul>

        <p>If you prefer to not include the root bundle in the top level module, you can define it like a normal locale bundle. In that case, the top level module would look like:</p>

        <pre><code class="javascript"><span class="comment">//my/nls/colors.js contents:</span>
define({
    <span class="string">"root"</span>: <span class="literal">true</span>,
    <span class="string">"fr-fr"</span>: <span class="literal">true</span>,
    <span class="string">"fr-fr-paris"</span>: <span class="literal">true</span>
});
</code></pre>

        <p>and the root bundle would look like:</p>

        <pre><code class="javascript"><span class="comment">//Contents of my/nls/root/colors.js</span>
define({
    <span class="string">"red"</span>: <span class="string">"red"</span>,
    <span class="string">"blue"</span>: <span class="string">"blue"</span>,
    <span class="string">"green"</span>: <span class="string">"green"</span>
});
</code></pre>

    </div>
</div>
